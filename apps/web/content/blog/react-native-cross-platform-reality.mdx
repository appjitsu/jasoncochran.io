---
title: "React Native in the Real World: Lessons from Cross-Platform Development"
date: "2024-08-10"
description: "Practical insights from building production React Native apps at Nutrien and Verizon, including the NFT collectibles platform"
tags: ["react-native", "mobile", "cross-platform", "typescript"]
---

React Native promises "write once, run anywhere." After building multiple production apps with it, including an NFT collectibles platform at Verizon and cross-platform components at Nutrien, I can tell you the reality is more nuanced - but still incredibly valuable.

## The NFT Collectibles Challenge

At Verizon, we built a full-stack NFT collectibles solution for AMC's Walking Dead franchise. The app needed to work seamlessly on iOS and Android while interfacing with the Ethereum blockchain and managing digital collectibles.

Here's a simplified version of how we handled blockchain interactions:

```typescript
// BlockchainService.ts
import { ethers } from 'ethers';

class BlockchainService {
  private provider: ethers.providers.Provider;
  private contract: ethers.Contract;

  constructor(contractAddress: string, abi: any) {
    this.provider = new ethers.providers.JsonRpcProvider(
      process.env.ETHEREUM_RPC_URL
    );
    this.contract = new ethers.Contract(
      contractAddress,
      abi,
      this.provider
    );
  }

  async getNFTMetadata(tokenId: string): Promise<NFTMetadata> {
    try {
      const tokenURI = await this.contract.tokenURI(tokenId);
      const response = await fetch(tokenURI);
      return await response.json();
    } catch (error) {
      console.error('Failed to fetch NFT metadata:', error);
      throw error;
    }
  }

  async getOwnerBalance(address: string): Promise<number> {
    return await this.contract.balanceOf(address);
  }
}
```

## Managing Blockchain Load with Queue Systems

One unique challenge was managing the load on blockchain nodes. We built a REST request scheduling system using Node.js, Express, Redis, and Socket.io:

```typescript
// QueueManager.ts
import Redis from 'ioredis';
import { Server } from 'socket.io';

class QueueManager {
  private redis: Redis;
  private io: Server;
  private processing = false;

  constructor(redisClient: Redis, socketServer: Server) {
    this.redis = redisClient;
    this.io = socketServer;
  }

  async enqueueRequest(request: BlockchainRequest): Promise<string> {
    const requestId = `req_${Date.now()}_${Math.random()}`;

    await this.redis.lpush(
      'blockchain_queue',
      JSON.stringify({ id: requestId, ...request })
    );

    if (!this.processing) {
      this.processQueue();
    }

    return requestId;
  }

  private async processQueue(): Promise<void> {
    this.processing = true;

    while (await this.redis.llen('blockchain_queue') > 0) {
      const item = await this.redis.rpop('blockchain_queue');
      if (!item) continue;

      const request = JSON.parse(item);

      try {
        const result = await this.executeBlockchainRequest(request);
        this.io.emit(`request_${request.id}`, {
          status: 'success',
          data: result
        });
      } catch (error) {
        this.io.emit(`request_${request.id}`, {
          status: 'error',
          error: error.message
        });
      }

      // Rate limiting - wait between requests
      await new Promise(resolve => setTimeout(resolve, 200));
    }

    this.processing = false;
  }
}
```

## Component Development at Nutrien

At Nutrien, working on a highly agile team meant building reusable, well-tested components. TypeScript was essential for maintaining consistency across web and mobile:

```typescript
// CustomButton.tsx
import React from 'react';
import {
  TouchableOpacity,
  Text,
  StyleSheet,
  ActivityIndicator
} from 'react-native';

interface CustomButtonProps {
  title: string;
  onPress: () => void;
  loading?: boolean;
  disabled?: boolean;
  variant?: 'primary' | 'secondary' | 'danger';
}

export const CustomButton: React.FC<CustomButtonProps> = ({
  title,
  onPress,
  loading = false,
  disabled = false,
  variant = 'primary'
}) => {
  return (
    <TouchableOpacity
      style={[
        styles.button,
        styles[variant],
        disabled && styles.disabled
      ]}
      onPress={onPress}
      disabled={disabled || loading}
      testID="custom-button"
    >
      {loading ? (
        <ActivityIndicator color="#fff" />
      ) : (
        <Text style={styles.text}>{title}</Text>
      )}
    </TouchableOpacity>
  );
};

// Jest + Enzyme testing
describe('CustomButton', () => {
  it('renders loading state correctly', () => {
    const wrapper = shallow(
      <CustomButton title="Submit" onPress={jest.fn()} loading />
    );
    expect(wrapper.find(ActivityIndicator)).toHaveLength(1);
  });
});
```

## Platform-Specific Considerations

React Native isn't truly "write once, run anywhere." You'll encounter platform differences:

```typescript
import { Platform } from 'react-native';

const styles = StyleSheet.create({
  container: {
    ...Platform.select({
      ios: {
        shadowColor: '#000',
        shadowOffset: { width: 0, height: 2 },
        shadowOpacity: 0.25,
        shadowRadius: 3.84,
      },
      android: {
        elevation: 5,
      },
    }),
  },
});
```

## CI/CD with CircleCI

We used CircleCI for automated testing and deployment:

```yaml
version: 2.1
jobs:
  test:
    docker:
      - image: circleci/node:14
    steps:
      - checkout
      - restore_cache:
          keys:
            - v1-dependencies-{{ checksum "package.json" }}
      - run: npm install
      - save_cache:
          paths:
            - node_modules
          key: v1-dependencies-{{ checksum "package.json" }}
      - run: npm test -- --coverage

  deploy:
    docker:
      - image: circleci/node:14
    steps:
      - checkout
      - run: npm install
      - run: npm run build:ios
      - run: npm run build:android
```

## Key Lessons

1. **TypeScript is essential**: The type safety saved us countless hours debugging
2. **Test thoroughly on both platforms**: What works on iOS might break on Android
3. **Performance monitoring matters**: Use tools like Flipper and React Native Debugger
4. **Native modules when needed**: Don't hesitate to write native code for performance-critical features
5. **State management scales**: We used Redux for complex apps, Context for simpler ones

React Native continues to mature, and with the new architecture rolling out, it's only getting better. For teams that need to target multiple platforms with limited resources, it remains an excellent choice.
