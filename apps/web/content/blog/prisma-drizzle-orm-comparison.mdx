---
title: "Prisma vs Drizzle: A Practical Comparison from Production Experience"
date: "2024-09-14"
description: "Comparing two popular TypeScript ORMs based on real-world usage in enterprise applications"
tags: ["prisma", "drizzle", "database", "typescript"]
---

Over the past few years, I've built production applications with both Prisma and Drizzle ORM. At Servant, we used Prisma with ZenStack for the EMA project, while recent projects have leveraged Drizzle with PostgreSQL. Here's what I've learned about each.

## Prisma: The Developer Experience Champion

Prisma revolutionized TypeScript ORMs with its schema-first approach and incredible developer experience. Here's a typical Prisma schema:

```prisma
// schema.prisma
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

model User {
  id        String   @id @default(uuid())
  email     String   @unique
  firstName String
  lastName  String
  role      UserRole
  referrals Referral[]
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Referral {
  id          String   @id @default(uuid())
  userId      String
  user        User     @relation(fields: [userId], references: [id])
  motherName  String
  status      String
  priority    Priority
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([userId])
  @@index([status])
}

enum UserRole {
  ADMIN
  COORDINATOR
  ADVOCATE
  MOTHER
}

enum Priority {
  LOW
  MEDIUM
  HIGH
  URGENT
}
```

The auto-generated client is type-safe and intuitive:

```typescript
// Using Prisma in a NestJS service
import { Injectable } from '@nestjs/common';
import { PrismaService } from './prisma.service';

@Injectable()
export class ReferralsService {
  constructor(private prisma: PrismaService) {}

  async create(data: CreateReferralDto) {
    return this.prisma.referral.create({
      data: {
        motherName: data.motherName,
        status: 'pending',
        priority: data.priority,
        user: {
          connect: { id: data.userId }
        }
      },
      include: {
        user: {
          select: {
            id: true,
            email: true,
            firstName: true,
            lastName: true
          }
        }
      }
    });
  }

  async findAllWithFilters(filters: ReferralFilters) {
    return this.prisma.referral.findMany({
      where: {
        status: filters.status,
        priority: filters.priority,
        user: {
          role: filters.userRole
        }
      },
      include: {
        user: true
      },
      orderBy: {
        createdAt: 'desc'
      }
    });
  }
}
```

## Prisma + ZenStack for Authorization

ZenStack extends Prisma with authorization rules at the schema level:

```prisma
// With ZenStack extensions
model Referral {
  id          String   @id @default(uuid())
  userId      String
  user        User     @relation(fields: [userId], references: [id])
  motherName  String

  // ZenStack access policies
  @@allow('create', auth().role == COORDINATOR || auth().role == ADVOCATE)
  @@allow('read', auth().role == ADMIN || userId == auth().id)
  @@allow('update', auth().role == COORDINATOR || userId == auth().id)
  @@deny('delete', true) // Soft delete only
}
```

This integrated beautifully with our authentication system and eliminated a lot of manual authorization checking.

## Drizzle: The SQL-First Approach

Drizzle takes a different philosophy - staying closer to SQL while providing type safety. Here's the equivalent schema:

```typescript
// schema.ts
import { pgTable, uuid, varchar, timestamp, pgEnum } from 'drizzle-orm/pg-core';
import { relations } from 'drizzle-orm';

export const userRoleEnum = pgEnum('user_role', [
  'admin',
  'coordinator',
  'advocate',
  'mother'
]);

export const priorityEnum = pgEnum('priority', [
  'low',
  'medium',
  'high',
  'urgent'
]);

export const users = pgTable('users', {
  id: uuid('id').defaultRandom().primaryKey(),
  email: varchar('email', { length: 255 }).notNull().unique(),
  firstName: varchar('first_name', { length: 100 }).notNull(),
  lastName: varchar('last_name', { length: 100 }).notNull(),
  role: userRoleEnum('role').notNull(),
  createdAt: timestamp('created_at').defaultNow().notNull(),
  updatedAt: timestamp('updated_at').defaultNow().notNull(),
});

export const referrals = pgTable('referrals', {
  id: uuid('id').defaultRandom().primaryKey(),
  userId: uuid('user_id').notNull().references(() => users.id),
  motherName: varchar('mother_name', { length: 255 }).notNull(),
  status: varchar('status', { length: 50 }).notNull(),
  priority: priorityEnum('priority').notNull(),
  createdAt: timestamp('created_at').defaultNow().notNull(),
  updatedAt: timestamp('updated_at').defaultNow().notNull(),
});

export const usersRelations = relations(users, ({ many }) => ({
  referrals: many(referrals),
}));

export const referralsRelations = relations(referrals, ({ one }) => ({
  user: one(users, {
    fields: [referrals.userId],
    references: [users.id],
  }),
}));
```

Querying with Drizzle feels closer to SQL:

```typescript
// Using Drizzle in a service
import { db } from './db';
import { referrals, users } from './schema';
import { eq, and, desc } from 'drizzle-orm';

export class ReferralsService {
  async create(data: CreateReferralDto) {
    const [referral] = await db
      .insert(referrals)
      .values({
        motherName: data.motherName,
        status: 'pending',
        priority: data.priority,
        userId: data.userId,
      })
      .returning();

    return referral;
  }

  async findAllWithFilters(filters: ReferralFilters) {
    return db
      .select()
      .from(referrals)
      .leftJoin(users, eq(referrals.userId, users.id))
      .where(
        and(
          filters.status ? eq(referrals.status, filters.status) : undefined,
          filters.priority ? eq(referrals.priority, filters.priority) : undefined
        )
      )
      .orderBy(desc(referrals.createdAt));
  }
}
```

## Key Differences

### Migration Workflow

**Prisma**: Schema-first with automatic migrations
```bash
npx prisma migrate dev --name add_referrals
npx prisma generate
```

**Drizzle**: More control, closer to raw SQL
```bash
npx drizzle-kit generate:pg
npx drizzle-kit push:pg
```

### Performance

Drizzle is generally lighter weight. For complex queries, Drizzle gives you more control:

```typescript
// Complex query with Drizzle
const result = await db
  .select({
    id: referrals.id,
    motherName: referrals.motherName,
    userName: sql`${users.firstName} || ' ' || ${users.lastName}`,
    daysOpen: sql`EXTRACT(DAY FROM ${referrals.createdAt} - NOW())`,
  })
  .from(referrals)
  .leftJoin(users, eq(referrals.userId, users.id))
  .where(eq(referrals.status, 'open'));
```

### Type Safety

Both provide excellent type safety, but Prisma's generated types feel more polished:

```typescript
// Prisma - incredibly smooth autocomplete
const user: User = await prisma.user.findUnique({...})

// Drizzle - also type-safe, slightly more verbose
const [user]: typeof users.$inferSelect[] = await db.select()...
```

## When to Use Each

**Choose Prisma when:**
- Developer experience is top priority
- You want comprehensive migrations and schema management
- You need features like ZenStack for row-level security
- Team is less familiar with SQL

**Choose Drizzle when:**
- Performance is critical
- You want to write custom SQL for complex queries
- You prefer staying close to SQL semantics
- Bundle size matters (Drizzle is lighter)

## Conclusion

Both ORMs are excellent choices for TypeScript applications. Prisma offers an unmatched developer experience and ecosystem, while Drizzle provides more control and better performance for SQL-heavy applications.

In my current projects, I'm leaning toward Drizzle for its lightweight nature and SQL-first approach, but I wouldn't hesitate to use Prisma for teams that value rapid development and comprehensive tooling.

The best choice depends on your specific needs, team expertise, and project requirements.
