---
title: "Offline-First Mobile Apps: Architecture and Sync Strategies"
date: "2024-08-14"
description: "Building mobile applications that work seamlessly offline and sync when connected, based on experience building WellPulse for oil field operations with unreliable connectivity."
tags: ["mobile", "react-native", "offline-first", "sqlite", "sync", "architecture"]
---

In the oil and gas industry, field workers spend most of their time in remote locations with zero cellular coverage. When we built WellPulse, a field operations app for well inspections and maintenance tracking, we faced a hard requirement: the app must work perfectly offline and sync seamlessly when connectivity returns.

After two years of running in production across hundreds of remote well sites, our offline-first architecture has proven reliable. Here's everything we learned about building truly offline-capable mobile applications.

## Why Offline-First?

Most mobile apps use an "online-first" approach: they require internet connectivity and maybe cache some data. This fails catastrophically in environments with poor or no connectivity.

Offline-first inverts this: the app works entirely offline by default, using a local database. When connectivity is available, it syncs with the server in the background. To the user, the app just works, whether they're deep in a canyon or in the office.

Benefits of offline-first:

- **Reliability**: App functions regardless of network state
- **Performance**: Instant UI updates (no waiting for network)
- **User experience**: No connection errors or loading spinners
- **Data integrity**: Changes aren't lost if connection drops
- **Battery life**: Fewer network requests

The cost is complexity: you're building a distributed system with sync, conflicts, and eventual consistency.

## The Local-First Architecture

Our architecture has three layers:

### 1. Local Database (SQLite)

SQLite is the source of truth on the device. Every read and write goes to SQLite first:

```typescript
// infrastructure/database/sqlite-database.ts
import * as SQLite from 'expo-sqlite';
import { drizzle } from 'drizzle-orm/expo-sqlite';

export class LocalDatabase {
  private db: ReturnType<typeof drizzle>;

  async initialize(): Promise<void> {
    const expo = SQLite.openDatabaseSync('wellpulse.db');
    this.db = drizzle(expo);

    // Run migrations
    await this.runMigrations();
  }

  getDb() {
    return this.db;
  }
}
```

### 2. Local Repository Layer

Repositories work entirely with SQLite, no network calls:

```typescript
export class LocalWellInspectionRepository implements WellInspectionRepository {
  constructor(private readonly db: LocalDatabase) {}

  async findById(id: string): Promise<WellInspection | null> {
    const result = await this.db
      .getDb()
      .select()
      .from(wellInspections)
      .where(eq(wellInspections.id, id))
      .limit(1);

    return result[0] ? this.toDomain(result[0]) : null;
  }

  async save(inspection: WellInspection): Promise<void> {
    const data = this.toPersistence(inspection);

    await this.db
      .getDb()
      .insert(wellInspections)
      .values({
        ...data,
        // Track that this needs syncing
        syncStatus: 'pending',
        lastModifiedAt: new Date(),
      })
      .onConflictDoUpdate({
        target: wellInspections.id,
        set: {
          ...data,
          syncStatus: 'pending',
          lastModifiedAt: new Date(),
        },
      });
  }
}
```

Notice the `syncStatus` field. Every record tracks whether it needs to be synced to the server.

### 3. Sync Service

The sync service runs in the background, pushing local changes and pulling server changes:

```typescript
export class SyncService {
  constructor(
    private readonly localDb: LocalDatabase,
    private readonly apiClient: APIClient,
    private readonly conflictResolver: ConflictResolver
  ) {}

  async sync(): Promise<SyncResult> {
    if (!await this.networkAvailable()) {
      return { status: 'skipped', reason: 'no network' };
    }

    try {
      // Push local changes to server
      await this.pushChanges();

      // Pull server changes to local
      await this.pullChanges();

      return { status: 'success' };
    } catch (error) {
      return { status: 'error', error };
    }
  }
}
```

## Data Modeling for Offline

Offline-first requires rethinking how you model data. Every record needs metadata for syncing:

```typescript
// schema/well-inspection.schema.ts
export const wellInspections = sqliteTable('well_inspections', {
  // Business data
  id: text('id').primaryKey(),
  wellId: text('well_id').notNull(),
  inspectorId: text('inspector_id').notNull(),
  inspectionDate: integer('inspection_date', { mode: 'timestamp' }),
  status: text('status').notNull(),
  findings: text('findings'), // JSON

  // Sync metadata
  syncStatus: text('sync_status').notNull().default('pending'),
  lastModifiedAt: integer('last_modified_at', { mode: 'timestamp' }).notNull(),
  serverVersion: integer('server_version'),
  deletedAt: integer('deleted_at', { mode: 'timestamp' }), // Soft delete
});
```

### Sync Status States

```typescript
type SyncStatus =
  | 'synced'      // In sync with server
  | 'pending'     // Local changes not yet pushed
  | 'syncing'     // Currently syncing
  | 'conflict'    // Merge conflict requires resolution
  | 'error';      // Sync failed
```

### Soft Deletes

Hard deletes don't work offline. If a user deletes a record while offline, we need to sync that deletion to the server. Solution: soft deletes.

```typescript
export class WellInspection {
  delete(): void {
    this.deletedAt = new Date();
    this.syncStatus = 'pending';
  }

  isDeleted(): boolean {
    return this.deletedAt !== null;
  }
}
```

When syncing, we push the deletion:

```typescript
async pushChanges(): Promise<void> {
  const deletedRecords = await this.db
    .select()
    .from(wellInspections)
    .where(
      and(
        eq(wellInspections.syncStatus, 'pending'),
        isNotNull(wellInspections.deletedAt)
      )
    );

  for (const record of deletedRecords) {
    await this.apiClient.delete(`/inspections/${record.id}`);

    // Now hard delete locally
    await this.db
      .delete(wellInspections)
      .where(eq(wellInspections.id, record.id));
  }
}
```

## Sync Strategies

We implemented several sync strategies:

### 1. Push: Local Changes to Server

```typescript
async pushChanges(): Promise<void> {
  const pendingRecords = await this.db
    .select()
    .from(wellInspections)
    .where(eq(wellInspections.syncStatus, 'pending'));

  for (const record of pendingRecords) {
    try {
      // Mark as syncing
      await this.updateSyncStatus(record.id, 'syncing');

      // Push to server
      const response = await this.apiClient.put(
        `/inspections/${record.id}`,
        this.toDTO(record)
      );

      // Update with server version
      await this.db
        .update(wellInspections)
        .set({
          syncStatus: 'synced',
          serverVersion: response.version,
        })
        .where(eq(wellInspections.id, record.id));
    } catch (error) {
      await this.updateSyncStatus(record.id, 'error');
      throw error;
    }
  }
}
```

### 2. Pull: Server Changes to Local

```typescript
async pullChanges(): Promise<void> {
  const lastSyncAt = await this.getLastSyncTimestamp();

  // Get changes since last sync
  const serverChanges = await this.apiClient.get(
    `/inspections/changes?since=${lastSyncAt.toISOString()}`
  );

  for (const change of serverChanges) {
    const localRecord = await this.db
      .select()
      .from(wellInspections)
      .where(eq(wellInspections.id, change.id))
      .limit(1);

    if (!localRecord[0]) {
      // New record from server, insert it
      await this.db.insert(wellInspections).values({
        ...this.fromDTO(change),
        syncStatus: 'synced',
      });
    } else if (localRecord[0].syncStatus === 'synced') {
      // No local changes, safe to update
      await this.db
        .update(wellInspections)
        .set({
          ...this.fromDTO(change),
          syncStatus: 'synced',
        })
        .where(eq(wellInspections.id, change.id));
    } else {
      // Local has pending changes - conflict!
      await this.handleConflict(localRecord[0], change);
    }
  }

  await this.setLastSyncTimestamp(new Date());
}
```

### 3. Incremental Sync

Don't sync everything every time. Track what changed:

```typescript
async getInspectionsToSync(): Promise<WellInspection[]> {
  return await this.db
    .select()
    .from(wellInspections)
    .where(
      and(
        eq(wellInspections.syncStatus, 'pending'),
        // Only sync inspections modified in last 30 days
        gt(wellInspections.lastModifiedAt, thirtyDaysAgo())
      )
    );
}
```

For initial sync after app install, we sync in batches:

```typescript
async initialSync(): Promise<void> {
  let page = 0;
  const pageSize = 100;

  while (true) {
    const records = await this.apiClient.get(
      `/inspections?page=${page}&limit=${pageSize}`
    );

    if (records.length === 0) break;

    await this.db.insert(wellInspections).values(
      records.map(r => ({
        ...this.fromDTO(r),
        syncStatus: 'synced',
      }))
    );

    page++;
  }
}
```

## Conflict Resolution

Conflicts happen when the same record is modified offline and on the server. We need strategies to resolve them.

### Strategy 1: Last Write Wins

Simplest approachâ€”newest timestamp wins:

```typescript
async handleConflict(
  local: WellInspectionRecord,
  server: WellInspectionDTO
): Promise<void> {
  if (local.lastModifiedAt > new Date(server.lastModifiedAt)) {
    // Local is newer, push to server
    await this.apiClient.put(`/inspections/${local.id}`, this.toDTO(local));

    await this.db
      .update(wellInspections)
      .set({ syncStatus: 'synced' })
      .where(eq(wellInspections.id, local.id));
  } else {
    // Server is newer, overwrite local
    await this.db
      .update(wellInspections)
      .set({
        ...this.fromDTO(server),
        syncStatus: 'synced',
      })
      .where(eq(wellInspections.id, local.id));
  }
}
```

### Strategy 2: Field-Level Merge

For complex records, merge at the field level:

```typescript
async mergeConflict(
  local: WellInspectionRecord,
  server: WellInspectionDTO
): Promise<void> {
  const merged = {
    id: local.id,
    // Use server's static data
    wellId: server.wellId,
    inspectorId: server.inspectorId,
    inspectionDate: server.inspectionDate,

    // Merge findings (append local findings)
    findings: [
      ...JSON.parse(server.findings),
      ...JSON.parse(local.findings).filter(
        f => !JSON.parse(server.findings).some(sf => sf.id === f.id)
      ),
    ],

    // Use latest status
    status: local.lastModifiedAt > new Date(server.lastModifiedAt)
      ? local.status
      : server.status,
  };

  await this.db
    .update(wellInspections)
    .set({
      ...merged,
      findings: JSON.stringify(merged.findings),
      syncStatus: 'synced',
    })
    .where(eq(wellInspections.id, local.id));
}
```

### Strategy 3: User Resolution

For critical data, let users resolve conflicts:

```typescript
async handleConflict(
  local: WellInspectionRecord,
  server: WellInspectionDTO
): Promise<void> {
  // Mark as conflict
  await this.db
    .update(wellInspections)
    .set({ syncStatus: 'conflict' })
    .where(eq(wellInspections.id, local.id));

  // Store server version for comparison
  await this.db.insert(conflictResolutions).values({
    entityType: 'well_inspection',
    entityId: local.id,
    localVersion: local,
    serverVersion: server,
  });

  // UI shows conflict resolution screen
}
```

Then provide a UI for users to choose:

```typescript
const ConflictResolutionScreen = ({ conflict }) => {
  const handleResolve = async (choice: 'local' | 'server' | 'custom') => {
    if (choice === 'local') {
      await syncService.resolveConflictWithLocal(conflict.entityId);
    } else if (choice === 'server') {
      await syncService.resolveConflictWithServer(conflict.entityId);
    } else {
      // Show custom merge UI
    }
  };

  return (
    <View>
      <Text>Conflict detected for Inspection #{conflict.entityId}</Text>
      <ConflictComparisonView local={conflict.localVersion} server={conflict.serverVersion} />
      <Button onPress={() => handleResolve('local')}>Use My Changes</Button>
      <Button onPress={() => handleResolve('server')}>Use Server Version</Button>
      <Button onPress={() => handleResolve('custom')}>Merge Manually</Button>
    </View>
  );
};
```

## Background Sync

Sync happens automatically in the background:

```typescript
// App.tsx
useEffect(() => {
  // Sync when app comes to foreground
  const subscription = AppState.addEventListener('change', (state) => {
    if (state === 'active') {
      syncService.sync();
    }
  });

  // Periodic background sync (every 15 minutes if online)
  const interval = setInterval(() => {
    syncService.sync();
  }, 15 * 60 * 1000);

  return () => {
    subscription.remove();
    clearInterval(interval);
  };
}, []);
```

For React Native, we use background tasks:

```typescript
import * as BackgroundFetch from 'expo-background-fetch';
import * as TaskManager from 'expo-task-manager';

const BACKGROUND_SYNC_TASK = 'background-sync';

TaskManager.defineTask(BACKGROUND_SYNC_TASK, async () => {
  try {
    await syncService.sync();
    return BackgroundFetch.BackgroundFetchResult.NewData;
  } catch (error) {
    return BackgroundFetch.BackgroundFetchResult.Failed;
  }
});

export async function registerBackgroundSync() {
  await BackgroundFetch.registerTaskAsync(BACKGROUND_SYNC_TASK, {
    minimumInterval: 15 * 60, // 15 minutes
    stopOnTerminate: false,
    startOnBoot: true,
  });
}
```

## UI Feedback for Sync Status

Users need to know sync status:

```typescript
const SyncStatusIndicator = () => {
  const { syncStatus, lastSyncAt, pendingChanges } = useSyncStatus();

  return (
    <View style={styles.statusBar}>
      {syncStatus === 'syncing' && (
        <ActivityIndicator />
        <Text>Syncing...</Text>
      )}

      {syncStatus === 'synced' && (
        <>
          <Icon name="check-circle" color="green" />
          <Text>Last synced {formatDistanceToNow(lastSyncAt)} ago</Text>
        </>
      )}

      {syncStatus === 'offline' && (
        <>
          <Icon name="wifi-off" color="orange" />
          <Text>Offline - {pendingChanges} changes pending</Text>
        </>
      )}

      {syncStatus === 'error' && (
        <>
          <Icon name="alert-circle" color="red" />
          <Text>Sync failed - tap to retry</Text>
        </>
      )}
    </View>
  );
};
```

## Optimistic UI Updates

The app feels fast because we update the UI immediately:

```typescript
const useCreateInspection = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async (inspection: CreateInspectionDTO) => {
      return await localRepository.save(inspection);
    },

    // Immediately update UI before sync
    onMutate: async (newInspection) => {
      await queryClient.cancelQueries(['inspections']);

      const previous = queryClient.getQueryData(['inspections']);

      queryClient.setQueryData(['inspections'], (old: Inspection[]) => [
        ...old,
        { ...newInspection, syncStatus: 'pending' },
      ]);

      return { previous };
    },

    // If mutation fails, rollback
    onError: (err, newInspection, context) => {
      queryClient.setQueryData(['inspections'], context.previous);
    },

    // Trigger sync in background
    onSuccess: () => {
      syncService.sync();
    },
  });
};
```

User creates an inspection, it appears instantly, and syncs in the background.

## Lessons Learned

### Lesson 1: SQLite is Reliable

We worried about SQLite performance and corruption. After two years, it's been rock solid. We've had zero data loss incidents.

### Lesson 2: Sync is Hard

Sync is the hardest part of offline-first. We spent 60% of development time on sync logic, conflict resolution, and edge cases. Budget accordingly.

### Lesson 3: Test Offline Extensively

We built tools to simulate network conditions:

```typescript
// Development only - simulate offline
if (__DEV__) {
  global.forceOffline = () => {
    NetworkInterceptor.blockAllRequests();
  };

  global.forceOnline = () => {
    NetworkInterceptor.allowAllRequests();
  };
}
```

### Lesson 4: Soft Deletes are Essential

Hard deletes break sync. Everything should be soft deleted with `deletedAt` timestamps.

### Lesson 5: Eventual Consistency is Acceptable

Field workers understood that changes might take a few minutes to sync across devices. Eventual consistency was fine for their workflows.

## When to Use Offline-First

Use offline-first when:

- Users work in environments with poor connectivity
- Data entry needs to continue regardless of network
- Mobile app is business-critical
- Users frequently switch between online/offline

Don't use offline-first when:

- Connectivity is reliable
- Real-time collaboration is essential
- Complexity isn't worth the benefit
- Your data model doesn't fit eventual consistency

## Conclusion

Building WellPulse with offline-first architecture transformed the field worker experience. They don't worry about connectivityâ€”they just do their work, and everything syncs automatically when possible.

The key ingredients:

- SQLite as local source of truth
- Sync metadata on every record
- Background sync with conflict resolution
- Optimistic UI updates
- Extensive offline testing

After 25 years of building applications, I can confidently say that offline-first is the future of mobile development for any app where reliability matters more than complexity.
